<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基础算法板子</title>
    <url>/2023/10/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = a[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[++i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span>(a[--j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(a, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="快速选择（第-k-个数）"><a href="#快速选择（第-k-个数）" class="headerlink" title="快速选择（第 k 个数）"></a>快速选择（第 k 个数）</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速选择，如果第k个数在左就在左区间找，在右就在右区间找</span></span><br><span class="line"><span class="comment">//由此保证答案在区间中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//区间长度为1时就是答案</span></span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> a[l];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = a[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[++i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span>(a[--j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//一趟快排后 前j个的数有哪些已经确定</span></span><br><span class="line">    <span class="type">int</span> lcnt = j - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= lcnt) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(a, l, j, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(a, j + <span class="number">1</span>, r, k - lcnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归出口 区间长度为0或1时已经有序</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先把左右区间都排好序</span></span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(a, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再有序合并两个区间到辅助数组</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//扫尾</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = a[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再把辅助数组拷贝给原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) a[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="逆序对的个数"><a href="#逆序对的个数" class="headerlink" title="逆序对的个数"></a>逆序对的个数</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归出口 区间长度为0或1时逆序对个数为0</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先分别求左右区间内部的逆序对个数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">merge_sort</span>(a, l, mid) + <span class="built_in">merge_sort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再求两个区间之间的逆序对个数</span></span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k++] = a[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++) a[i] = tmp[j];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//最后返回总共的逆序对个数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="二分的本质"><a href="#二分的本质" class="headerlink" title="二分的本质"></a>二分的本质</h3><blockquote>
<p>根据某种性质，将一段区间分成有这个性质和没有这个性质的两段，二分出的就是这两段的边界。</p>
</blockquote>
<p>因此有单调性一定可以二分，没单调性也可能可以二分。</p>
<h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><ol>
<li>先确定答案所在区间 $[L, R]$</li>
<li>考虑用什么性质来二分</li>
<li>每次更新区间都要包含答案</li>
<li>当 $L &#x3D;&#x3D; R$ 时，区间长度为 $1$，就是答案</li>
</ol>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//(1)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;<span class="comment">//(2)</span></span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意(1)(2)</span></span><br><span class="line"><span class="comment">//当 r = l + 1 时，如果 mid = (l + r) / 2 = l =&gt; l = mid = l，就会死循环</span></span><br><span class="line"><span class="comment">//因此改为 mid = (l + r + 1) / 2</span></span><br></pre></td></tr></table></figure></div>

<p>二分一定有答案，可以根据二分答案判断题目是否有解。</p>
<h3 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> eps = <span class="number">1e-8</span>;<span class="comment">//经验值，一般比题目保留位数多两位</span></span><br><span class="line"><span class="keyword">while</span>(r - l &gt; eps)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//r - l &lt;= eps 时，就认为 l 或 r 是答案了</span></span><br></pre></td></tr></table></figure></div>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="高精度-高精度"><a href="#高精度-高精度" class="headerlink" title="高精度 + 高精度"></a>高精度 + 高精度</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++)<span class="comment">//</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次循环开始，t是进位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line"></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//两个个位数相加，再/=10，只可能是1或0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cout &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="高精度-高精度-1"><a href="#高精度-高精度-1" class="headerlink" title="高精度 - 高精度"></a>高精度 - 高精度</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A &gt;= B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i]) <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sub</span>(B, A);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次循环开始，t是借位</span></span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//t &gt;= 0 --&gt; t % 10</span></span><br><span class="line">        <span class="comment">//t &lt; 0  --&gt; t + 10</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理前导0</span></span><br><span class="line">    <span class="comment">//如 00000 --&gt; 0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C = <span class="built_in">sub</span>(A, B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cout &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="高精度-高精度-2"><a href="#高精度-高精度-2" class="headerlink" title="高精度 * 高精度"></a>高精度 * 高精度</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    C.<span class="built_in">resize</span>(A.<span class="built_in">size</span>() + B.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; B.<span class="built_in">size</span>(); j++)</span><br><span class="line">            C[i + j] += A[i] * B[j];<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; C.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i + <span class="number">1</span>] += C[i] / <span class="number">10</span>;<span class="comment">//</span></span><br><span class="line">        C[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理前导0</span></span><br><span class="line">    <span class="comment">//如 00000 --&gt; 0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C = <span class="built_in">mul</span>(A, B);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cout &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="高精度-低精度"><a href="#高精度-低精度" class="headerlink" title="高精度 &#x2F; 低精度"></a>高精度 &#x2F; 低精度</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a; <span class="type">int</span> b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//除法从高位开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = t * <span class="number">10</span> + A[i];<span class="comment">//每次循环开始，t是余数</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t / b);</span><br><span class="line">        t %= b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//处理前导0</span></span><br><span class="line">    <span class="comment">//比如商可能是000....</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) cout &lt;&lt; C[i];</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//t是余数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里给出的板子，只有加法不需要处理前导零。</p>
<h2 id="前缀和（下标从-1-开始）"><a href="#前缀和（下标从-1-开始）" class="headerlink" title="前缀和（下标从 1 开始）"></a>前缀和（下标从 1 开始）</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">a[<span class="number">1</span>] + ... + a[i] = s[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作</span></span><br><span class="line">s[i] = s[i - <span class="number">1</span>] + a[i]</span><br><span class="line">a[l] + ... + a[r] = s[r] - s[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></div>

<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line">s[i][j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">    </span><br><span class="line"><span class="comment">//以(x1, y1)为左上角，(x2, y2)为右下角的矩阵的所有元素的和</span></span><br><span class="line">s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></div>

<h2 id="差分（下标从-1-开始）"><a href="#差分（下标从-1-开始）" class="headerlink" title="差分（下标从 1 开始）"></a>差分（下标从 1 开始）</h2><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//差分就是前缀和的逆运算</span></span><br><span class="line">b[i] = a[i] - a[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心操作</span></span><br><span class="line"><span class="comment">//给区间[l, r]中的每个数加上c</span></span><br><span class="line"><span class="comment">//只需对差分数组b这样操作</span></span><br><span class="line">b[l] += c, b[r + <span class="number">1</span>] -= c</span><br><span class="line"><span class="comment">//然后对b求前缀和就是操作后的原数组</span></span><br></pre></td></tr></table></figure></div>

<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c</span></span><br><span class="line">b[x1][y1] += c;</span><br><span class="line">b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure></div>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="求二进制的第-k-位（以最低位为第-0-位）"><a href="#求二进制的第-k-位（以最低位为第-0-位）" class="headerlink" title="求二进制的第 k 位（以最低位为第 0 位）"></a>求二进制的第 k 位（以最低位为第 0 位）</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//右移 k 位，再 &amp; 1</span></span><br><span class="line">x &gt;&gt; k &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="求二进制的最后一位-1"><a href="#求二进制的最后一位-1" class="headerlink" title="求二进制的最后一位 1"></a>求二进制的最后一位 1</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回二进制最后一个1</span></span><br><span class="line"><span class="comment">//如x = 1110 -&gt; -x = 0010</span></span><br><span class="line"><span class="comment">//x &amp; -x = 0010</span></span><br><span class="line">x &amp; -x</span><br></pre></td></tr></table></figure></div>

<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></div>

<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp; segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排完序才能从左往右扫描</span></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());<span class="comment">//STL支持字典序比较运算</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;<span class="comment">//题中左端点最小-1e9，故用-2e9当负无穷</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后一个区间</span></span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>二分</tag>
        <tag>高精度</tag>
        <tag>前缀和</tag>
        <tag>差分</tag>
        <tag>位运算</tag>
        <tag>去重</tag>
        <tag>区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>图论板子</title>
    <url>/2023/11/17/%E5%9B%BE%E8%AE%BA%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串板子</title>
    <url>/2023/10/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>$KMP$ 是一种字符串匹配算法，即匹配主串 $s$ 和模式串 $p$，主串长度为 $m$，模式串长度为 $n$</p>
<p>暴力的做法，是在当前字符不匹配的时候，主串和模式串都回溯。</p>
<p>$KMP$ 则是主串不回溯，模式串回溯到特定位置，这个特定位置由模式串的 $next$ 数组决定。</p>
<p>建议下标从 $1$ 开始读入字符串：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> s[N], p[N];</span><br><span class="line"><span class="type">int</span> ne[N], m, n;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求模式串的next数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">    <span class="keyword">if</span> (j == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 匹配成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>字符串$hash$，就是通过哈希函数，把字符串映射成一个哈希值。</p>
<p>哈希函数的实现：</p>
<ul>
<li><p>可以将字符串看作一个 $P$ 进制数（ $P$ 经验值 $131$ ），每位的值是该字符的$ASCII$码值。</p>
</li>
<li><p>求出这个 $P$ 进制数的值，再$mod$一个较小的数（经验值 $2^{64}$），就是该字符串的哈希值。</p>
</li>
</ul>
<p>模板题：<a class="link"   href="https://www.acwing.com/activity/content/problem/content/891/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;<span class="comment">//溢出时等价mod2^64</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, P = <span class="number">131</span>;</span><br><span class="line">ull h[N], p[N];<span class="comment">//h[i]存前i个字符的哈希，p[i]存P的i次方</span></span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预处理h[N]和p[N]</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>字典树可以高效地存储、查询字符串。</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">//son[当前位置][儿子内容] = 儿子位置</span></span><br><span class="line"><span class="comment">//cnt[当前位置] = 以当前位置结尾的字符串的个数</span></span><br><span class="line"><span class="comment">//idx = 当前用到了哪个位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>)<span class="comment">//0表示根也表示空</span></span><br><span class="line">        &#123;</span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">        &#125;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>KMP</tag>
        <tag>字符串哈希</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>数论板子</title>
    <url>/2023/11/17/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>递归、搜索和回溯</title>
    <url>/2023/10/15/%E9%80%92%E5%BD%92%E3%80%81%E6%90%9C%E7%B4%A2%E5%92%8C%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p>函数自己调用自己</p>
<h3 id="什么时候可以用递归"><a href="#什么时候可以用递归" class="headerlink" title="什么时候可以用递归"></a>什么时候可以用递归</h3><p>有重复子问题</p>
<h3 id="如何看待递归函数（重要）"><a href="#如何看待递归函数（重要）" class="headerlink" title="如何看待递归函数（重要）"></a>如何看待递归函数（重要）</h3><p><strong>看作一个黑盒</strong></p>
<h3 id="如何编写递归代码"><a href="#如何编写递归代码" class="headerlink" title="如何编写递归代码"></a>如何编写递归代码</h3><ol>
<li>找到子问题</li>
<li>设计函数头</li>
<li>考虑递归出口</li>
<li>编写函数体</li>
</ol>
<h3 id="1-汉诺塔问题"><a href="#1-汉诺塔问题" class="headerlink" title="1. 汉诺塔问题"></a>1. 汉诺塔问题</h3><p><a class="link"   href="https://leetcode.cn/problems/hanota-lcci/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>参考代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hanota</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b, vector&lt;<span class="type">int</span>&gt;&amp; c)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//dfs(x, y, z, n)</span></span><br><span class="line">        <span class="comment">//把 x 的 n 个盘子 借助 y 放到 z</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(a, b, c, a.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b, vector&lt;<span class="type">int</span>&gt;&amp; c, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c.<span class="built_in">push_back</span>(a.<span class="built_in">back</span>());</span><br><span class="line">            a.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 a 的 n - 1 个盘子 借助 c 放到 b</span></span><br><span class="line">        <span class="built_in">dfs</span>(a, c, b, n - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把 a 的最后一个盘子 放到c</span></span><br><span class="line">        c.<span class="built_in">push_back</span>(a.<span class="built_in">back</span>());</span><br><span class="line">        a.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把 b 的 n - 1 个盘子 借助 a 放到 c</span></span><br><span class="line">        <span class="built_in">dfs</span>(b, a, c, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-合并两个有序链表"><a href="#2-合并两个有序链表" class="headerlink" title="2. 合并两个有序链表"></a>2. 合并两个有序链表</h3><p><a class="link"   href="https://leetcode.cn/problems/merge-two-sorted-lists/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>题目要求的是返回新的升序链表的头结点</p>
<ol>
<li>找到子问题：返回头结点，合并剩下的两个链表。</li>
<li>设计函数头：函数返回一个结点，参数是剩下的两个链表。本题给出的接口就满足我们的需求。</li>
<li>考虑递归出口：当前合并的两个链表，如果有一个为空，则返回另一个链表的头结点。</li>
<li>编写函数体：当前两个结点中较小的当作头结点，头结点的 $next$ 指向下一次返回的结点，最后返回这个头结点。</li>
</ol>
<p>参考代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> list1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> mi = list1-&gt;val &lt;= list2-&gt;val ? list1 : list2;</span><br><span class="line">        <span class="keyword">auto</span> ma = list1-&gt;val &gt; list2-&gt;val ? list1 : list2;</span><br><span class="line">        mi-&gt;next = <span class="built_in">mergeTwoLists</span>(mi-&gt;next, ma);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-反转链表"><a href="#3-反转链表" class="headerlink" title="3. 反转链表"></a>3. 反转链表</h3><p><a class="link"   href="https://leetcode.cn/problems/reverse-linked-list/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>参考代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口 只有0个或1个结点 无需反转 直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">       	</span><br><span class="line">        <span class="comment">//先反转后面的结点</span></span><br><span class="line">        <span class="comment">//递归函数看作黑盒</span></span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再将当前结点反转</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>循环（迭代）写法：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = head, pre = (ListNode*)<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-快速幂"><a href="#4-快速幂" class="headerlink" title="4. 快速幂"></a>4. 快速幂</h3><p><a class="link"   href="https://leetcode.cn/problems/powx-n/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>参考代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span> / x;</span><br><span class="line">	    </span><br><span class="line">        <span class="comment">//先求 x 的 n / 2 次方 x1</span></span><br><span class="line">        <span class="type">double</span> x1 = <span class="built_in">myPow</span>(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//再求 x 的 n % 2 次方 x2</span></span><br><span class="line">        <span class="type">double</span> x2 = <span class="built_in">myPow</span>(x, n % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x1 * x1 * x2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></div>





]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>搜索</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构板子</title>
    <url>/2023/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//头指针，一开始指向空</span></span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//头插</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span><span class="comment">//在k后面插入一个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> k)</span><span class="comment">//删除k后面的一个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>双链表常用于优化某些问题</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//默认0为头结点，1为尾结点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>; l[<span class="number">1</span>] = <span class="number">0</span>; idx = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//l[0] = 1; r[1] = 0; 循环双链表再加上这句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span><span class="comment">//在k后面插入一个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    l[r[idx]] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> k)</span><span class="comment">//删除k</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>常见题型：</p>
<p>求每个数左边第一个比它小的数；<br>求每个数左边第一个比它大的数；<br>求每个数右边第一个比它小的数；<br>求每个数右边第一个比它大的数；</p>
<p>这里以求每个数左边第一个比它小的数为例。</p>
<p>暴力的做法是设置一个指针 $i$ 从左往右遍历，$i$ 每枚举到一个数，就用另一个指针 $j$ 反向扫描它前面的数并找到第一个比它小的值。显然这样的做法是 $O(N^2)$ 的。</p>
<p>这里我们发现，每次枚举到下一个数的时候，都只有一个新的数加入到它左边待扫描的区间。因此我们只要维护一个栈，保证每次入栈前，把栈里不小于待插值的数先弹出，此时如果栈不为空，栈顶就是第一个小于它的数，最后再将待插值入栈即可。</p>
<p>总共枚举 $N$ 次，栈里的每个数都最多被插入弹出一次，所以时间复杂度是线性的。其实就是优化了求较小值的过程，从扫描一段区间变成直接取栈顶元素。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/832/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>参考代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt;= x) stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; stk.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        stk.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>常见题型：</p>
<p>滑动窗口求最值；</p>
<p>首先，滑动窗口可以用一个队列来维护，滑动窗口每次向右走一步，队尾就插入一个数，如果滑动窗口的区间长度是定值，那么此时队头如果不合法就要弹出一个数。</p>
<p>暴力的做法是，滑动窗口每走一步，都扫描一遍滑动窗口的区间求最值。显然这种做法是 $O(N^2)$ 的。</p>
<p>如何优化呢？以求最大值为例，每枚举一个数入队之前，都把队列里不大于它的数弹出，再将这个数入队，以此来维护一段单调递减的区间。这样滑动窗口每次求最大值，就只需要取队头元素。</p>
<p>同样的，总共枚举 $N$ 次，队列里的每个数都最多被插入弹出一次，时间复杂度是线性的。其实就是优化了求最值的过程，把扫描一遍滑动窗口优化成直接取队头元素。</p>
<p><a class="link"   href="https://www.acwing.com/problem/content/156/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>参考代码：</p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;<span class="comment">//队列存下标，才能判断队头合法性</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//滑动窗口最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头合法性: 右端为i，长度为k的区间：[i - k + 1, i]</span></span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) dq.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//维护队列单调递增</span></span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; a[dq.<span class="built_in">back</span>()] &gt;= a[i]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//滑动窗口最小值取队头即可</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k) cout &lt;&lt; a[dq.<span class="built_in">front</span>()] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空队列</span></span><br><span class="line">    dq.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滑动窗口最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头合法性: 右端为i，长度为k的区间：[i - k + 1, i]</span></span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt; i - k + <span class="number">1</span>) dq.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//维护队列单调递减</span></span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; a[dq.<span class="built_in">back</span>()] &lt;= a[i]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//滑动窗口最大值取队头即可</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k) cout &lt;&lt; a[dq.<span class="built_in">front</span>()] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><p>模板题：<a class="link"   href="https://www.acwing.com/problem/content/838/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="comment">//p[x]是x的父亲</span></span><br><span class="line"><span class="comment">//p[x]==x  表示x是根  根存的是集合的编号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)<span class="comment">//如果x不是根</span></span><br><span class="line">        p[x] = <span class="built_in">find</span>(p[x]);<span class="comment">//让x的父亲变成根  路径压缩</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p[x];<span class="comment">//返回集合编号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        p[i] = i;<span class="comment">//一开始每个元素都是一个集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;M&quot;</span>) </span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//合并集合就是让一个根当另一个根的父亲</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))<span class="comment">//在同一集合就是集合编号相同</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h3><p>模板题：<a class="link"   href="https://www.acwing.com/problem/content/839/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N], sz[N];</span><br><span class="line"><span class="comment">//sz在每个集合的根处记录集合的元素个数</span></span><br><span class="line"><span class="comment">//一个连通块就是一个集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        sz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;C&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))<span class="comment">//在同一个连通块中 </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            sz[<span class="built_in">find</span>(b)] += sz[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;Q1&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            cout &lt;&lt; sz[<span class="built_in">find</span>(a)] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆排序：<a class="link"   href="https://www.acwing.com/problem/content/840/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以h[1]为堆顶</span></span><br><span class="line"><span class="comment">//左孩子: 2 * x</span></span><br><span class="line"><span class="comment">//右孩子: 2 * x + 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N], sz;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= sz &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= sz &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t != u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t], h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &gt;= <span class="number">1</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; h[i];</span><br><span class="line">    sz = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(N)建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; h[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="comment">//删除堆顶元素</span></span><br><span class="line">        <span class="built_in">swap</span>(h[<span class="number">1</span>], h[sz]);</span><br><span class="line">        sz--;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>原理：把一个较大的数映射成一个较小的下标，存到哈希表的该下标位置。</p>
<p>映射方法有很多，最简单的就是 <code>hash(x) = (x % N + N) % N</code></p>
<p>处理哈希冲突的方法也有很多。这里介绍的拉链法，是将冲突的值都连在同一条链上。</p>
<p>模板题：<a class="link"   href="https://www.acwing.com/problem/content/842/" >题目链接 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">3</span>;<span class="comment">//mod质数冲突最少</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;<span class="comment">//保证不为负</span></span><br><span class="line"></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));<span class="comment">//初始每条链的头指针都指向空</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s; <span class="type">int</span> x; cin &gt;&gt; s &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;I&quot;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">query</span>(x)) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>单链表</tag>
        <tag>双链表</tag>
        <tag>单调栈</tag>
        <tag>单调队列</tag>
        <tag>并查集</tag>
        <tag>堆</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
</search>
